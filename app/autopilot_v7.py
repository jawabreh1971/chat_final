# app/autopilot_v7.py
"""
AutoPilot v7 router — يُحفَظ كـ app/autopilot_v7.py
يوفر راوتر على /autopilot/tick و /autopilot/healthz و صفحة Console صغيرة على /
هذا الملف لا يُنشئ FastAPI() جديدة، فقط APIRouter.
"""

from typing import Optional, Dict, Any, List, Callable
from enum import Enum
from fastapi import APIRouter, Depends
from fastapi.responses import HTMLResponse
from pydantic import BaseModel, Field
from typing import Dict, Any, List
try:
    from sqlalchemy.orm import Session
except Exception:
    # إذا لم تكن sqlalchemy مثبتة، نعرّف نوع بديل بسيط للتوافق على مستوى الأنواع فقط
    Session = Any  # type: ignore

# ====== راوتر ======
autopilot_router = APIRouter(prefix="/autopilot", tags=["autopilot"])

# ====== محاولة الحصول على get_db من مكان مركزي (اختياري) ======
try:
    from dependencies import get_db
except Exception:
    try:
        # محاولة استخدام get_db من main إذا كانت متاحة
        from main import get_db as _get_db
        def get_db():
            return _get_db()
    except Exception:
        # بديل افتراضي يرفع خطأ إذا استُدعي (يعني لا يوجد DB)
        def get_db():
            raise RuntimeError("get_db is not configured for AutoPilot v7")

# ====== محاولة الحصول على دالة تخزين تدقيق (audit) ======
try:
    from audit import store_audit
except Exception:
    def store_audit(db: Session, event: str, data: Dict[str, Any]) -> None:
        # بديل لطباعة السجل في حالة عدم وجود نظام تدقيق مركزي
        print(f"[AUDIT][{event}] {data}")

# ====== موديلات و Utilities ======
class OverallRiskLevel(str, Enum):
    low = "low"
    medium = "medium"
    high = "high"

class AutoPilotInput(BaseModel):
    evm: Optional[Dict[str, Any]] = None
    procurement: Optional[Dict[str, Any]] = None
    radar: Optional[Dict[str, Any]] = None
    media: Optional[Dict[str, Any]] = None
    vision: Optional[Dict[str, Any]] = None
    extra: Optional[Dict[str, Any]] = None

class AutoPilotAction(BaseModel):
    id: str
    engine_id: str
    title: str
    description: str
    severity: float
    impact: float
    priority_score: float
    category: str
    recommended_action: str
    auto_executable: bool
    requires_approval: bool
    source: Dict[str, Any] = Field(default_factory=dict)

class AutoPilotResponse(BaseModel):
    actions: List[AutoPilotAction]
    governance_decision: str
    ethics_level: str
    final_decision: str
    meta: Dict[str, Any] = Field(default_factory=dict)

def _safe_backend_call(func: Callable[[Dict[str, Any]], Dict[str, Any]], payload: Optional[Dict[str, Any]]) -> Dict[str, Any]:
    if not payload:
        return {}
    try:
        return func(payload)
    except Exception as exc:
        return {"error": str(exc)}

def _clamp01(value: float) -> float:
    try:
        v = float(value)
    except Exception:
        v = 0.0
    return max(0.0, min(1.0, v))

# ====== محركات محلية وهمية (يمكن استبدالها باتصالات لباك إند حقيقي) ======
def _backend_evm(payload: Dict[str, Any]) -> Dict[str, Any]:
    spi = payload.get("SPI")
    cpi = payload.get("CPI")
    items = payload.get("items") or []
    if spi is None or cpi is None:
        total_planned = 0.0
        total_earned = 0.0
        total_actual_cost = 0.0
        for it in items:
            planned = float(it.get("planned_value", 0.0) or 0.0)
            earned = float(it.get("earned_value", 0.0) or 0.0)
            actual_cost = float(it.get("actual_cost", 0.0) or 0.0)
            total_planned += planned
            total_earned += earned
            total_actual_cost += actual_cost
        if spi is None:
            spi = (total_earned / total_planned) if total_planned > 0 else 1.0
        if cpi is None:
            cpi = (total_earned / total_actual_cost) if total_actual_cost > 0 else 1.0
    spi = float(spi or 1.0)
    cpi = float(cpi or 1.0)
    return {"SPI": spi, "CPI": cpi, "status": "ok", "message": "EVM computed locally by AutoPilot v7."}

def _backend_procurement(payload: Dict[str, Any]) -> Dict[str, Any]:
    items = payload.get("items") or []
    alerts: List[Dict[str, Any]] = []
    for it in items:
        alerts.append({
            "code": it.get("code"),
            "needed_date": it.get("needed_date"),
            "order_deadline": it.get("order_deadline"),
            "critical": bool(it.get("critical", False))
        })
    return {"alerts": alerts, "status": "ok", "message": "Procurement alerts generated by AutoPilot v7."}

def _backend_radar(payload: Dict[str, Any]) -> Dict[str, Any]:
    alerts = payload.get("alerts")
    if alerts is None:
        patients = payload.get("patients") or []
        alerts = []
        for p in patients:
            missing = p.get("missing_tests") or p.get("pending") or []
            if missing:
                alerts.append({"patient_id": p.get("id") or p.get("patient_id"), "missing": missing})
    return {"alerts": alerts, "status": "ok", "message": "Radar alerts generated by AutoPilot v7."}

def _backend_media(payload: Dict[str, Any]) -> Dict[str, Any]:
    sentiment = payload.get("sentiment")
    if sentiment is None:
        score = float(payload.get("alarm_score", 0.0) or 0.0)
        sentiment = "alarmist" if score >= 0.7 else "neutral"
    return {"sentiment": sentiment, "status": "ok", "message": "Media sentiment inferred by AutoPilot v7."}

def _backend_vision(payload: Dict[str, Any]) -> Dict[str, Any]:
    sectors_in = payload.get("sectors") or []
    sectors_out = []
    for s in sectors_in:
        planned = float(s.get("planned", 0.0) or 0.0)
        actual = float(s.get("actual", 0.0) or 0.0)
        gap = s.get("gap")
        if gap is None:
            gap = planned - actual
        sectors_out.append({"name": s.get("name"), "planned": planned, "actual": actual, "gap": float(gap)})
    return {"sectors": sectors_out, "status": "ok", "message": "Vision gaps computed by AutoPilot v7."}

def _backend_intelligence(payload: Dict[str, Any]) -> Dict[str, Any]:
    signals = payload.get("signals") or []
    scored: List[Dict[str, Any]] = []
    for s in signals:
        sev = _clamp01(s.get("severity", 0.0))
        imp = _clamp01(s.get("impact", 0.0))
        prio = s.get("priority_score")
        if prio is None:
            prio = 0.6 * sev + 0.4 * imp
        s = dict(s)
        s["severity"] = sev
        s["impact"] = imp
        s["priority_score"] = float(prio)
        scored.append(s)
    scored.sort(key=lambda x: x["priority_score"], reverse=True)
    return {"signals": scored}

def _backend_core(payload: Dict[str, Any]) -> Dict[str, Any]:
    engines = payload.get("engines") or []
    down_engines = [e for e in engines if e.get("status") == "down"]
    degraded = bool(down_engines)
    core_status = "healthy"
    if degraded:
        core_status = "degraded"
    return {"status": core_status, "down_engines": down_engines}

def _backend_governance(payload: Dict[str, Any]) -> Dict[str, Any]:
    req = payload.get("request") or {}
    risk = req.get("risk_level", OverallRiskLevel.low)
    decision = "allow"
    if str(risk) == OverallRiskLevel.high.value:
        decision = "review"
    elif str(risk) == OverallRiskLevel.medium.value:
        decision = "monitor"
    return {"decision": decision, "policies": payload.get("policies") or []}

def _backend_ethics(payload: Dict[str, Any]) -> Dict[str, Any]:
    req = payload.get("request") or {}
    uses_sensitive = bool(req.get("uses_sensitive_data"))
    may_harm = bool(req.get("may_cause_harm"))
    level = "low"
    if uses_sensitive and may_harm:
        level = "high"
    elif uses_sensitive or may_harm:
        level = "medium"
    return {"ethical_risk_level": level}

def _backend_arkhilion(payload: Dict[str, Any]) -> Dict[str, Any]:
    core = payload.get("core") or {}
    gov = payload.get("governance") or {}
    ethics = payload.get("ethics") or {}
    gov_dec = gov.get("decision", "allow")
    ethics_lvl = ethics.get("ethical_risk_level", "low")
    final = "allow"
    if gov_dec == "review" or ethics_lvl == "high":
        final = "hold"
    elif gov_dec == "monitor":
        final = "allow_with_monitoring"
    return {"final_decision": final, "core_status": core.get("status", "unknown"), "governance_decision": gov_dec, "ethics_level": ethics_lvl}

# ====== نقطة النهاية الرئيسية: /autopilot/tick ======
@autopilot_router.post("/tick", response_model=AutoPilotResponse)
def autopilot_tick(body: AutoPilotInput, db: Session = Depends(get_db)) -> AutoPilotResponse:
    raw_results: Dict[str, Any] = {}

    if body.evm:
        raw_results["evm"] = _safe_backend_call(_backend_evm, body.evm)
    if body.procurement:
        raw_results["procurement"] = _safe_backend_call(_backend_procurement, body.procurement)
    if body.radar:
        raw_results["radar"] = _safe_backend_call(_backend_radar, body.radar)
    if body.media:
        raw_results["media"] = _safe_backend_call(_backend_media, body.media)
    if body.vision:
        raw_results["vision"] = _safe_backend_call(_backend_vision, body.vision)

    signals: List[Dict[str, Any]] = []
    evm_res = raw_results.get("evm") or {}
    if evm_res:
        spi = float(evm_res.get("SPI", 1.0))
        cpi = float(evm_res.get("CPI", 1.0))
        sev = _clamp01(max(1 - spi, 1 - cpi))
        impact = 0.7
        signals.append({
            "id": "evm_status",
            "engine_id": "evm",
            "title": "تأخر/ضغط في المشروع (EVM)",
            "description": f"SPI={spi:.2f}, CPI={cpi:.2f}",
            "severity": sev,
            "impact": impact,
            "category": "project_controls",
            "recommended_action": "راجع الأنشطة على المسار الحرج، وضبط الموارد أو إعادة تسلسل بعض البنود.",
            "source": evm_res
        })

    proc_res = raw_results.get("procurement") or {}
    if proc_res:
        alerts = proc_res.get("alerts", [])
        for idx, a in enumerate(alerts):
            critical = bool(a.get("critical"))
            sev = 0.9 if critical else 0.6
            impact = 0.8
            signals.append({
                "id": f"proc_{idx}",
                "engine_id": "procurement",
                "title": f"طلب شراء لبند {a.get('code')}",
                "description": f"Deadline: {a.get('order_deadline')} / Needed: {a.get('needed_date')}",
                "severity": sev,
                "impact": impact,
                "category": "procurement",
                "recommended_action": "إطلاق أمر شراء الآن أو مراجعة خطة التوريد.",
                "source": a
            })

    radar_res = raw_results.get("radar") or {}
    if radar_res:
        alerts = radar_res.get("alerts", [])
        for idx, a in enumerate(alerts):
            sev = 0.85
            impact = 0.9
            signals.append({
                "id": f"radar_{idx}",
                "engine_id": "radar",
                "title": "مريض بحاجة متابعة",
                "description": f"Patient {a.get('patient_id')} - {a.get('missing')}",
                "severity": sev,
                "impact": impact,
                "category": "medical",
                "recommended_action": "التواصل مع المريض وتحديد موعد فحص/زيارة.",
                "source": a
            })

    media_res = raw_results.get("media") or {}
    if media_res:
        sentiment = media_res.get("sentiment")
        if sentiment == "alarmist":
            sev = 0.7
            impact = 0.5
            signals.append({
                "id": "media_alarm",
                "engine_id": "media",
                "title": "نبرة مهوّلة",
                "description": "النبرة تبدو مهوّلة (alarmist) وتحتاج تدقيق.",
                "severity": sev,
                "impact": impact,
                "category": "media",
                "recommended_action": "مراجعة الخبر يدويًا أو تمريره لمحرك تحليل أعمق.",
                "source": media_res
            })

    vision_res = raw_results.get("vision") or {}
    if vision_res:
        sectors = vision_res.get("sectors", [])
        for idx, s in enumerate(sectors):
            gap = float(s.get("gap", 0))
            if gap <= 0:
                continue
            planned = float(s.get("planned") or 1.0)
            sev = _clamp01(gap / planned)
            impact = 0.6
            signals.append({
                "id": f"vision_{idx}",
                "engine_id": "vision",
                "title": f"تأخر في محور {s.get('name')}",
                "description": f"Gap={gap:.2f} (planned={s.get('planned')}, actual={s.get('actual')})",
                "severity": sev,
                "impact": impact,
                "category": "vision",
                "recommended_action": "إعادة توجيه الموارد أو مراجعة المبادرات تحت هذا المحور.",
                "source": s
            })

    if not signals:
        resp = AutoPilotResponse(actions=[], governance_decision="allow", ethics_level="low", final_decision="allow", meta={"note": "لا توجد إشارات ذات أولوية حالياً.", "raw_results": raw_results})
        try:
            store_audit(db, event="autopilot_tick", data={"actions_count": 0, "overall_risk": "low"})
        except Exception:
            pass
        return resp

    intel_out = _backend_intelligence({"signals": signals})
    ordered_signals = intel_out.get("signals", signals)

    max_sev = max(float(s.get("severity", 0)) for s in ordered_signals)
    max_impact = max(float(s.get("impact", 0)) for s in ordered_signals)

    overall_risk = OverallRiskLevel.low.value
    if max_sev >= 0.8 or max_impact >= 0.8:
        overall_risk = OverallRiskLevel.high.value
    elif max_sev >= 0.5 or max_impact >= 0.5:
        overall_risk = OverallRiskLevel.medium.value

    engines_state = []
    for engine_id in ["evm", "procurement", "radar", "media", "vision"]:
        status = "ok"
        engine_signals = [s for s in ordered_signals if s.get("engine_id") == engine_id]
        if any(float(s.get("severity", 0)) >= 0.9 for s in engine_signals):
            status = "down"
        engines_state.append({"id": engine_id, "status": status})

    core_out = _backend_core({"engines": engines_state})
    extra = body.extra or {}
    gov_request = {"risk_level": overall_risk, "country": extra.get("country")}
    gov_policies = [{"type": "high_risk"}]
    gov_out = _backend_governance({"request": gov_request, "policies": gov_policies})

    ethics_request = {"uses_sensitive_data": bool(body.radar), "may_cause_harm": overall_risk == OverallRiskLevel.high.value}
    ethics_out = _backend_ethics({"request": ethics_request})

    arkhilion_out = _backend_arkhilion({"core": core_out, "governance": gov_out, "ethics": ethics_out})

    actions: List[AutoPilotAction] = []
    for idx, s in enumerate(ordered_signals):
        sev = float(s.get("severity", 0))
        imp = float(s.get("impact", 0))
        prio = float(s.get("priority_score", sev * 0.6 + imp * 0.4))
        auto_executable = (sev <= 0.4 and overall_risk != OverallRiskLevel.high.value)
        requires_approval = not auto_executable
        actions.append(AutoPilotAction(
            id=s.get("id") or f"sig_{idx}",
            engine_id=s.get("engine_id", "unknown"),
            title=s.get("title", "Action"),
            description=s.get("description", ""),
            severity=sev,
            impact=imp,
            priority_score=prio,
            category=s.get("category", "general"),
            recommended_action=s.get("recommended_action", ""),
            auto_executable=auto_executable,
            requires_approval=requires_approval,
            source=s.get("source") or {}
        ))

    try:
        store_audit(db, event="autopilot_tick", data={"actions_count": len(actions), "overall_risk": overall_risk, "final_decision": arkhilion_out.get("final_decision")})
    except Exception:
        pass

    return AutoPilotResponse(
        actions=actions,
        governance_decision=gov_out.get("decision", "allow"),
        ethics_level=ethics_out.get("ethical_risk_level", "low"),
        final_decision=arkhilion_out.get("final_decision", "allow"),
        meta={"overall_risk": overall_risk, "core": core_out, "governance": gov_out, "ethics": ethics_out, "arkhilion": arkhilion_out, "raw_results": raw_results}
    )

# ====== health endpoint ======
@autopilot_router.get("/healthz")
def healthz():
    return {"status": "ok", "service": "pai6-autopilot-v7"}

# ====== small HTML console (optional) ======
HTML_PAGE = """<!doctype html><html lang="ar" dir="rtl"><head><meta charset="utf-8"/><title>PAI-6 AutoPilot v7 Console</title><meta name="viewport" content="width=device-width,initial-scale=1"/></head><body><h2>AutoPilot v7 Console</h2><p>انسى الواجهة، استخدم /api/autopilot/tick للعمل.</p></body></html>"""

@autopilot_router.get("/", response_class=HTMLResponse)
def console_root():
    return HTML_PAGE
